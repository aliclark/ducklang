


Why:`

This file is a collection of various methods to exercise and hash out various ideas in Ducklang.
`



::2020::Number::



use Number


square of self ->
	self ** 2


cube of self ->
	self ** 3



::2020::Function::



itself of self ->
	self



::2020::Sequences::



use Number,
    infinity


power of self:
	for each number in infinity,
		collect self ** number


factorial:
	for each number through infinity,
		when number
			is 0:      collect 1
			otherwise: collect number * (factorial (number - 1))


fibonacci:
	Why:`A benefit of using a 'through' sequence versus 'in' itemization is language-provided memory of results
		 which means it does not take extra time to recurse - f(n-1) and f(n-2) is already memorized.`
	for each number through infinity,
		when number
			is 0: collect 0
			is 1: collect 1
			otherwise: collect (fibonacci (number - 1)) + (fibonacci (number - 2))


lucas:
	for each number through infinity,
		when number
			is 0: collect 2
			is 1: collect 1
			otherwise: collect (lucas (number - 1)) + (lucas (number - 2))



::2020::Sequences::Even::



use Number,
    infinity


evenNumbers:
	for each number in infinity,
		collect number * 2



::2020::Sequences::Odd::



use Number,
    evenNumbers


oddNumbers:
	for each number in evenNumbers,
		collect number + 1



::2020::Ranges::



use Number,
    infinity


countingFrom self with numbersLessThan limit (otherwise default infinity):
	for each number in infinity, to extent of limit - self,
		collect self + number


numbersLessThan self:
	for each number in infinity, to extent of self,
		collect number


numbersGreaterThan self:
	for each number in countingFrom self,
		collect number + 1


countingTo self:
	for each number in numbersLessThan self,
		collect number + 1



::2020::Numbers::



use Number,
    evenNumbers,
    oddNumbers


evenNumbersLessThan self:
	for each number in evenNumbers, to extent of roundedUp (self / 2),
		collect number


oddNumbersLessThan self:
	for each number in oddNumbers, to extent of roundedDown (self / 2),
		collect number



::2020::Itemizing::



resultFromEach of self with ["mapping"] = ...input:
	:items of self
	resultFromEach of items with mapping



::2020::Items::



use evenNumbers


resultFromEach of self with ["mapping"] = ...input:
	for each x in self,
		collect resultOf (mapping in x)


everyOther of self:
	lookup = offsetOf in self
	for each offset in evenNumbers,
		Issue: Needs to be something like resultFrom lookup ...
		collect lookup of offset



::2020::Aliquot::



use Number,
    String


aliquotSum of self:
	when self
		is 1:
			return 0

		otherwise:
			variable:sum = 1

			:squareRoot of self

			for each number in countingFrom 2 with numbersLessThan: squareRoot, do:
				when remainder of self with divisor: number
					is 0:
						variable:sum =+ number + (self / number)

			when square of roundedDown squareRoot
				is self:
					variable:sum =+ squareRoot

			return variable:sum


aliquotClassification of self:
	when compare self with 1
		is 'less':
			error 'Input must be a positive integer'
		otherwise:
			:aliquotSum of self
			when compare aliquotSum with self
				is 'less':    return 'deficient'
				is 'greater': return 'abundant'
				otherwise:    return 'perfect'



::2020::Rocket::



use Number,
    List,
    String,
    Fraction,
    log,
    blaster,
    turbo,
    offset,
    square


launchBoosters of self with thrust level,
                            trajectory angle (otherwise default 0.0),
                            turboState (otherwise default 'unknown'):
	numbers = [1, 2, 3]

	variable:stage = 0
	variable:cache = resultFromEach of numbers with square

	variable:resultFromEach of numbers with square

	variable:{ foo, bar } = variable:cache

	for each x in turbo, do:
		variable:stage =+ 1
		engage turbo with thruster: x

	boost blaster with { { stage } = variable, level,
	                     angle, offset } otherwise default 'done'


engageBoosters of self with thrust,
                            angle (otherwise default 0.0),
                            color (otherwise default 'green'):

	checksResult = preCheck blaster with angle, thrust

	add log with info: 'Hi {name}! Your favourite drink is {drink}.'

	:status of turbo with { angle, thrust,
	                        :usage of self } otherwise default 'poor'

	when status
		is 'good':
			add log with info: 'Turbo is go!'
			return launchBoosters of self with angle, thrust, status

		is 'okay':
			add log with warning: 'Turbo is iffy :/'
			return launchBoosters of self with angle, thrust, status

		otherwise:
			return 'stopped'



::2020::Ideas::



use Number,
    List,
    String,
    infinity,
    square


testStructuring of self with { name, color, speed } = options,
                             ["mapping"] = ...input:

	["first", ..."rest"] = input

	l1 = [1, 2, 3]
	l2 = [1, 2]

	l4 = [2, 3, 9]
	l3 = [1, l4]

	Why: an example to show list matching is possible with different input length
	["a", "b"] = l1

	bob:foo:["a", ["b", "c", ..."rest"] = "innerList"] = l3

	numbers = l1
	variable:resultFromEach of numbers with square

	variable:{ foo, bar } = variable:cache

	foo = 1
	bar = 2
	variable:{ foo, bar }


test1 of self with { { ["d" (otherwise default 2), { f (otherwise default 1) } = "e"] = c } = b } = a:
	return a


test2 of self with [..."bob"] = a:
	return bob


test3 of self with ...inputs:
	[entry1, ...entries] = inputs
	["value1", ..."values"] = inputs
	Issue: not implemented yet: return entry1
	Issue: not implemented yet: return values
	return inputs


firstFive self:
	for each number in infinity, to extent of 5,
		collect number



::2020::firstFiveDoubled::



use Number,
    firstFive


firstFiveDoubled self:
	for each number in firstFive,
		collect number * 2



::2020::firstTwoDoubled::



use Number,
    firstFiveDoubled


firstTwoDoubled self:
	for each number in firstFiveDoubled, to extent of 2,
		collect number



::2020::printFirstDoubled::



use Number,
    String,
    firstTwoDoubled


printFirstDoubled self:
	for each number in firstTwoDoubled, to extent of 1, do:
		display number


test4 of self with [abc, "def", ..."rest"] = input1,
                   { xyz } = input2,
                   ...values:
	return values


test5 of self with [...rest] = input1:
	return rest


stringTest of self with input1 ->
	'input1 is {input1}'


locatorTest of self with input1:
	z = input1:abc:def
	y = input1:abc
	g = input1:abc:def:ghi
	h:x:y:z = 30

	...
	... add some stuff here
	...


whenHasTest of self with input1:
	data = { year: 50, name: 'Sally' }
	when data
		has name:
			return name
		has year:
			return year



::2020::Point::new::



use Data


new self with x,
              y:
	dimensions:{ x, y }
	return dimensions


distance of self with point:
	a = point:x - self:x
	b = point:y - self:y
	return squareRoot of ((square a) + (square b))



::2020::Point::Category::



use Category,
    new,
    distance


Point ->
	Issue: assignWith is still unimplemented, should be:
	... methods: { new, distance }
	new Category with method1: new, method2: distance



::2020::Program::run::



use software,
    Data,
    String


run self:
	return self



::2020::Program::program::



use run


program self:
	{ software, Data, String } = self

	components = import software with
		Blaster:        { author: 'terry', version: '2020' },
		turboConcept:   { author: 'jill',  version: '2019' },
		rocketConcept:  { author: 'alex',  version: '2020-03' },
		RocketFix:      { author: 'rick',  version: '2020' },
		programConcept: { author: 'clive', version: '2018' }

	follow components with run



::2020::Program::new::



use base,
    program


new self ->
	:duck base
	follow duck with program



::2020::Program::



use Category,
    new


Program ->
	new Category with method: new


